---
layout: post
title:  "On JS, Promises & Async/Await"
date:   2020-10-17 19:00:00 +0000
tags: JavaScript
---
In the 10 years (since the start), I have mainly worked on `C/C++ software development`. I have used `Python` over that span to simulate mathematical models for the signal processing implementations we desired. So I had built a programming-model mainly built on these 3 languages and in systems that did not have much CPU to run on. Recently, I started working on TypeScript and before I say anything, I would like to post something that the creator of node.JS said:
>You can never understand everything. But, you should push yourself to understand the system.
>-Ryan Dahl

That is a handy insight. JS was made that responsiveness of bandwidth in a loosely connected world is tolerated. This therefore can result in creating a space in which developers can scale up faster. The development experience was enriched. The power of asynhronous programming model, devs were left to play around with application without worrying too much about portability, threading issues, tooling cost, updatability and overall development costs. A reminder/introduction of the event loop is now important in brief for programmers similar to my experience. Firstly, there are no threads in JS. As far as the developer is concerned everything is being run as statements are found by incrementing/branching. On the other hand events can also be onto queue which gets executed at some point the engine decides to pop the queue. There is some heap provided for allocation but deallocation is taken care of by the JS engine. Publisher-subscriber model with game loops seem to be a good idea then for the JS programmer's model. The amount of cpu/memory space allocated to the `event-loop thread` is a question we are not sure about and actually works to the advantage of the developer. An abstraction is created from which business intelligence logic can be written upon. A clear demarcation of stacks for most of the applications that can sustain some performance hit.

![JS Programming model](/images/The_Javascript_Runtime_Environment_Example.svg "JS Programmer's model"){:.centre-image}

*(Pic courtesy Mozilla: [A further deep dive into the elements of the JS programmers's model](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)).*

Leveraging the asynchronicity was important to allow using up time spent waiting for blocking I/O. So if an operation blocks, the subsequent operations resulting from the operation passing/failing can be called back later. This is what is widespreadly used and has become a programming idiom strongly associated with JS. For example:

{% highlight typescript %}
type CallBackFn = (error: ErrorType, response: ResponseData) => void;

function read(request: RequestData, cb: CallBackFn): void {
    let err: ErrorType;
    let resp: ResponseData;

    // Block on I/O
    // Upon receiving data process and save in err, resp
    if(cb) {
        (err, resp);
    }
}
{% endhighlight %}

The `read` function can take multiple routes and the above code sample is just an example. There is nothing stopping anyone to call another callback only if the `CallbackFn` takes another argument called `CallbackFn`. A call back on the other hand can be `undefined`. The above though leads to nested calls or `callback hell`. A general structure to callback is below. As you can see `callback hell` is really `readability hell`. It follows a general structure of `Do something-> If something passes then do A -> Else do B`. This structure got baked into `ES6` in the form of `Promises` which aids readability.

{% highlight typescript %}
function GetFile(request: RequestData, cb: CallBackFn): void {
    let data1: []number;
    // ...
    // ...
    func1(data1, (data2: []number, err: ErrorType) => {
        if(err) {
            console.log("Failed in func1");
        } else {
            func2(data2, (data3: []number, err: ErrorType) => {
                if(err) {
                    console.log("Failed in func2");
                } else {
                    func3(data3: []number, (data4: number, err: ErrorType) => {
                        // ...
                    }
                }
            });
        }
    });
}
{% endhighlight %}

Promises is just a type which has a `then` & `catch` method. `catch` is called when a `reject` callback is called while `then` is called when a `resolve` is called. Something like below. However, it is assumed that `func1` returns a `Promise`.

{% highlight typescript %}
function GetFile(request: RequestData, cb: CallBackFn): void {
    let data: []number;

    func1(data1)
        .then((resolve, reject, data: []number) => {
            let err: ErrorType | undefined;
            // Do something which sets/unsets err.
            if(err) {
                reject()
            } else {
                resolve()
            }
        })
        .then((resolve, reject, data: []number) => {//replaces func2}) 
        // ...
        .then((resolve, reject, data: []number) => {//replaces funcN})
        .catch((error: ErrorType) => console.log(`[ERROR]: ${error}`));
}
{% endhighlight %}

As seen the `then` method calls the `callback` provided and passes the `resolve` or `reject` callbacks. As explained before, `resolve` calls the next callback which in turn calls `func3`. If an error occurs, `reject` gets called which in turn calls `catch` and does not add anything else into the event queue. The above code as seen improves readability but still lags requires writing down callbacks into the function argument such that a single line spans multiple lines. This is again solved by the `async/await` construct of Javascript. A function if `async` can have an `await` function call in its body. The `function` is called `async` by placing `async` keyword before the function definition. `await` keyword precedes a function that returns a `Promise`. It is made sure by the Javascript engine that statements beyond the `await` call will be added to the event queue only when a `resolved Promise` is returned by the callback. On the other hand a `rejected Promise` can be caught using `try...catch` which can lie at the top level of the code. An example which is a modified version of Mozilla's example is as below.

{% highlight typescript %}
function resolveAfter2Seconds() {
  return new Promise((resolve,reject) => {
    setTimeout(() => {
      reject('Unresolved');
    }, 2000);
  });
}

async function asyncCall() {
  console.log('calling');
  try {
  const result = await resolveAfter2Seconds();
  console.log(result);
  // expected output: "resolved"
  } catch(err) {
    console.log(err)
  }
}

asyncCall();
console.log("Done")
{% endhighlight %}

It is clear that once you use `async\await` there is no need for code smells like `callback hell` and `promise chaining`. It makes the code look more readable while utilizing the asynchronous property of the JavaScript engine. But that explanation is complete with the `explanation` of the event loop. This is where Ryan's quote acted a guiding force in my search of explanations of these constructs coming from the background that I come from.