---
layout: post
title:  "On JS, Promises & Async/Await"
date:   2020-10-17 19:00:00 +0000
tags: JavaScript
---
In the 10 years (since the start) of my programming experience, I have mainly worked on `C/C++ software development`. I have used `Python` over that span to simulate mathematical models for signal processing implementations. So my contextual programming-model is primed on these 3 languages and working on systems that did not have much CPU/memory to run on. Recently, I started working on TypeScript and before I say anything, I would like to post something that the creator of node.JS said:
>You can never understand everything. But, you should push yourself to understand the system.
>-Ryan Dahl

That is a handy insight as writing good JS code will require the developer to understand the system running it. JS was made for systems where millisecond responsiveness is not required. I/O's and memory reads/writes take time and that time could be utilized for some other statements. Due to the reduction in requirements for responsiveness problems like threading are relaxed and can be abstracted out. A memory management system is an added advantage. This is where the `event queue` and `stack` comes in. For developers, are added to the `stack` in a procedural manner. On the other hand, `events/callbacks` can be added onto the queue which gets executed at a point when the engine decides. Heap memory provided for the objects is managed by the JS engine while the developer does not worry about memory management. `Publisher-subscriber` architecture with `game loops` are well suited for the abstractons provided by the JS engine. The developer can focus more on business logic scaling instead.

![JS Programming model](/images/The_Javascript_Runtime_Environment_Example.svg "JS Programmer's model"){:.centre-image}

*(Pic courtesy Mozilla: [A further deep dive into the elements of the JS programmers's model](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)).*

Leveraging the asynchronicity is important to allow using up time spent waiting for blocking I/O as explained before. If an operation blocks, operations that follow can be called later when an I/O transfer finishes in the form of a function object being passed and called. This function is called a `callback` and is widely used in Javascript applications. For example:

{% highlight typescript %}
type CallBackFn = (error: ErrorType, response: ResponseData) => void;

function read(request: RequestData, cb: CallBackFn): void {
    let err: ErrorType;
    let resp: ResponseData;

    // Block on I/O
    // Upon receiving data process and save in err, resp
    if(cb) {
        (err, resp);
    }
}
{% endhighlight %}

Callbacks can call other functions and so on. This happens when certain calls need to occur in a certain order. This however, leads to nested calls or `callback hell`. A general structure to callback is below. As you can see `callback hell` is really `readability hell`. It follows a general structure of `Do something-> If something passes then do A -> Else do B`. This structure got baked into `ES6` in the form of `Promises` which aids readability.

{% highlight typescript %}
function GetFile(request: RequestData, cb: CallBackFn): void {
    let data1: []number;
    // ...
    // ...
    func1(data1, (data2: []number, err: ErrorType) => {
        if(err) {
            console.log("Failed in func1");
        } else {
            func2(data2, (data3: []number, err: ErrorType) => {
                if(err) {
                    console.log("Failed in func2");
                } else {
                    func3(data3: []number, (data4: number, err: ErrorType) => {
                        // ...
                    }
                }
            });
        }
    });
}
{% endhighlight %}

Promises is just a type which has a `then` & `catch` method. `catch` is called when a `reject` callback is called whereas a `then` is called when a `resolve` is called. Something like below. It is assumed that `func1` returns a `Promise`.

{% highlight typescript %}
function GetFile(request: RequestData, cb: CallBackFn): void {
    let data: []number;

    func1(data1)
        .then((resolve, reject, data: []number) => {
            let err: ErrorType | undefined;
            // Do something which sets/unsets err.
            if(err) {
                reject()
            } else {
                resolve()
            }
        })
        .then((resolve, reject, data: []number) => {//replaces func2}) 
        // ...
        .then((resolve, reject, data: []number) => {//replaces funcN})
        .catch((error: ErrorType) => console.log(`[ERROR]: ${error}`));
}
{% endhighlight %}

As seen the `then` method calls the `callback` provided and passes the `resolve` or `reject` callbacks. As explained before, `resolve` calls the next callback which in turn calls `func3`. If an error occurs, `reject` gets called which in turn calls `catch` and skips all the `thens` in between. The above code as seen improves readability. This however, results in `promise chaining` where multiple then calls have to made in a single statement. Although better than before, it still suffers from readability issues.

This is solved by the `async/await` construct of Javascript. A function if `async` can have an `await` function call in its body. The `function` is called `async` by placing `async` keyword before the function definition. `await` keyword precedes a function call that returns a `Promise`. It is made sure by the Javascript engine that statements beyond the `await` call will be added to the event queue only when a `resolved Promise` is returned by the callback. On the other hand a `rejected Promise` can be caught using `try...catch` which can lie at the top level of the code. An example which is a modified version of Mozilla's example is as below.

{% highlight typescript %}
function resolveAfter2Seconds() {
  return new Promise((resolve,reject) => {
    setTimeout(() => {
      reject('Unresolved');
    }, 2000);
  });
}

async function asyncCall() {
  console.log('calling');
  try {
  const result = await resolveAfter2Seconds();
  console.log(result);
  // expected output: "resolved"
  } catch(err) {
    console.log(err)
  }
}

asyncCall();
console.log("Done")
{% endhighlight %}

It is clear that once you use `async\await` there is no need for code smells like `callback hell` and `promise chaining`. It makes the code look more readable while utilizing the asynchronous property of the JavaScript engine.